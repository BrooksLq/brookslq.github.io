{"pages":[{"title":"","text":"tas6BedVSt","link":"/baidu_verify_tas6BedVSt.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Deep Learning 学习磨难记","text":"前言： 作为一名现役程序猿，个人博客理应是发布一些技术类文章为主，辅以生活&amp;兴趣等。结果，目前为止，我貌似算是比较多愁善感。 最近一段时间在学习了Python之后，就像深度学习进军。结果，没走一步都如深陷泥沼，不知道是该感到难过还是幸运。难过，是这个经历的体现；幸运，若是趟过了这个磨难那于己来说必是大大有益。 目前为止，看了两本书，主要追一节视频，也看了不少其他的视频部分和文章一堆。最终，脑子里还是一团浆糊的状态。 关于，机器学习、人工智能、深度学习、监督分类、非监督分类、二分类、线性回归、非线性回归、神经元、神经网络、正向传播、反向传播、损失函数、成本函数&amp;梯度下降等这些名词多少还是有所明白。 BUT!但是！ 此刻的我，当这些概念连在一起的时候，就是不能够理顺它们的关系。不理解，前者为什么要接着后者，为什么要用这个不用那个之类。字我都认得，文章却是看不懂。 对了，还有就是数学的底子还是需要一些的，至少能够更好的理解公式或者更深入的理解理论依据吧。而这，又是我较为薄弱的地方。 不过，仔细想想，一般目前的从业者不是个博士也是个硕士，或者都是浸淫其中多年的老鸟了。我这个半路出家还全靠自学的家伙，又怎么能奢望着短短一周多的日子就即刻入门，还门儿清。 给自己几点建议： 把数学的一些相关知识重新找回来，夯实基础。 专注于吴恩达的视频课程即可，不要受其他干扰，信他就专注于他。 视频课程可以一股脑的先过着，但是编程题目必须弄明白！ 自己结束一个课程，一定需要整理知识，并将知识点连贯。","link":"/Deep-Learning-学习磨难记/"},{"title":"Mac OS环境下 安装 OpenCV 的坑","text":"OpenCV简介以及安装 前因 OpenCV全称:Open Source Computer Vision Library，是一个开源的跨平台计算机视觉库，github地址：https://github.com/opencv/opencv。 在进行人脸识别的课程练习中，需要添加cv2这个库，于是了解到指的就是OpenCV。首先尝试了直接用pycharm进行下载，当然是以失败告终，理由是版本问题……紧接着，找到一篇博文，跟着步骤进行下载，倒是成功了。 安装我是直接使用Homebrew进行安装OpenCVC，没有使用pip，所以不清楚究竟哪个是最方便。直接在终端执行 brew install opencv 紧接着，会自己安装需要的依赖库，以及opencv。这里，一定要注意：OpenCV的安装目录为：/usr/local/Cellar/opencv/。当下载之后会用得到的。 OK，当一段时间过去，已经全部下载完毕。如果不幸出现问题，请自行解决，我运气比较好没在这个过程中遇到问题。这时，如果尝试，import cv2 ,很不好意思，依然会是找不到模块。如果注意看终端信息，会发现有这么一句话： Python modules have been installed and Homebrew’s site-packages is notin your Python sys.path, so you will not be able to import the modulesthis formula installed. If you plan to develop with these modules,please run: mkdir -p /Users/brooks/Library/Python/2.7/lib/python/site-packages echo ‘import site; site.addsitedir(“/usr/local/lib/python2.7/site-packages”)’ &gt;&gt; /Users/brooks/Library/Python/2.7/lib/python/site-packages/homebrew.pth 大意就是，我们安装的库不在python能调用的路径之下，因此需要将文件cv2.so复制到Python/site-packages。另，此处的Python，可以使python2.7，也可以是python3.6。 填坑还记得切记记住的OpenCV安装路径吗？此时，就需要进入该路径下，找到openCV，并依次找到我们需要的文件cv2.so，然后移至上文说的路径之下即可。 此时，再重新打开pycharm，会发现可以成功import cv2。 ps：python3.6下的cv2名字有点长，需要改为cv2.so。","link":"/Mac-OS环境下安装OpenCV(Python)/"},{"title":"Mac安装Dlib库教程","text":"前言：当使用opencv做人脸检测的时候，从一些博文资料中了解到dlib的库貌似检测准确度比opencv高得多。于是，又是一番踩坑。 1、必要的依赖 dlib安装使用，是需要一些依赖的，亲测，的确是需要的。需要安装的依赖项如下： opencv(安装可以看这里) openblas &amp; X11(安装参考这里)- 关于dlib的安装，直接引用【SnailTyan】博文中的内容部分： 12345cd dlib/examplesmkdir buildcd buildcmake .. -DUSE_SSE4_INSTRUCTIONS=ONcmake --build . --config Release 2、折磨人的坑如果按照上面的执行完毕，其实，的确可以直接在终端窗口import成功。但是，当在pycharm中import时却找不到模块。在这个过程中，了解到有可能是因为【环境】问题，安装的dlib不是在当前环境之下。（此处，可以去了解下python的虚拟环境，会对项目版本控制有所帮助。不过目前为止，自己还没有真正去每个项目一个环境来用。） 仔细看执行完毕之后的信息，会发现有个Boost需要安装，而它也给出了安装的引导代码。当然，既然知道会有这个坑，我们肯定提前装好就行啦。 1234567891011brew install cmakebrew install boostbrew install boost-python --with-python3//验证brew list | grep cmake# 如果成功安装，则有如下显示cmakebrew list | grep boost# 如果boost和boost-python成功安装，则有如下显示boostboost-python 这个时候，如果在pycharm中引用还报错，那就需要去看看:pycharm -&gt; preference -&gt; project -&gt; project interpreterrun -&gt; edit configurations -&gt; project interpreter两者所指定的解释器是否一致，设置成一致，理应结束采坑。 参考： Mac下dlib安装 MAC安装Opencv以及Dlib碰到的一些问题 macOS下安装Dlib和Python2.7","link":"/Mac安装Dlib库教程（Python）/"},{"title":"python学习实例记录","text":"前言：尽管只用对着书本敲代码，都险些中断了这个python实例的练习。终于，完成。 1.游戏 “打飞机”这个实例完全是照着书本进行，除了出现过两三次由于粗心抄错了字母这样的情况，整个项目手打下来并没有遇到奇怪的问题。而且，跟着书本进行，也没有不能理解的地方。特别值得一提的是，一定要根着书本的进程敲代码，不要直接下载资源跑源码。 跟着书本进行，作者会引导着如何重构代码，更能深入的体会到面向对象的编程以及养成良好的编码习惯——注释、命名和抽象方法等。 而关于游戏的实现，则主要是依赖pygame这个第三方库的使用。 屏幕显示 事件处理 绘制图形 Sprite …… Talk is cheap, Show you the code ps.click me to github 2.数据可视化 关于数据可视化，主要会使用到两个包：matplotlib和Pygal。 matplotlib是一个数学绘图库，可以使用它进行图表绘制，如折线图和散点图等。直接进入官网，点击图表，就可以看到源码进行学习。 Pygal是一个SVG图表库，专注于生成适合在数字设备上显示的图表，通过它可以优化用户与图表直间的交互。 3.Web应用 Django是一个Web框架——一套用于帮助开发交互式网站的工具。通过它可以让开发者修改或直接使用“模板”，创建自己的Web应用程序。 后记：后面两个项目并没有进行实践，只是阅读了书本进行了解，待到有需求动力时或者过段时间也许再进行实践。 直接上自己的练习代码！","link":"/python学习实例记录/"},{"title":"iOS上架流程&踩坑集","text":"前言：不能上架的APP不是好APP。 上架流程 1、当程序准备好之后，连接上一台真机，执行Product-&gt;Archive。 ps：这里需要注意，在项目General-&gt;Identity-&gt;build每上传一次，就需要+1；版本号（Version）也需要进行适当的更改。 2、执行完第一步之后，会弹出一个新的窗口，选中自己生成的需要上传的APP，点击右边栏目中蓝色的Upload to App Store …按钮即可。接下来就是一路的Next。 ps:如果一切配置都没问题，就会一路畅通到最后。 3、打开iTunes管理，登录账号，在【我的APP】中选择上架的APP,如果是第一次上架那自然就是创建一个即可。 ps: 目前还没有自己创建过APP，所以并不清楚有什么需要注意的地方。 4、点进上架的APP控制界面之后，在左侧栏目，需要创建一个新的版本，然后把相关的APP信息填写之后，执行完【2】成功之后邮箱过一会能够收到信息，这时刷新一下界面，【构建版本】就可以选择了。紧接着就是，【保存】-&gt;【提交】。 ps:在提交的时候，会有一些选项，看自己的情况选择即可。目前，公司的项目貌似都是Next即可。 *WAITTING ^_^ GOOD LUCK * 坑坑坑1 在执行【2】步骤时，出现了秘钥没有安装的问题。 解决： 首先，检查一下在【General】中，【Signing】是否勾选了【Automatically】，总之取消勾选。另外就是选择好对应（那就是不报错，不犯红）的dev和dis证书文件（Provisioning Profile）。 其次，可能需要安装p12文件，这个装的一直都是迷迷糊糊的……反正，这是一个方向吧 坑2 在执行【2】步骤时，出现了需要输入电脑用户名和密码以访问钥匙链的一个窗口，却永无休止的提示而不会终止。 解决： 将证书文件从电脑钥匙链中的【系统】下面移到【登录】就可以解决，感谢一位不知名的群友。","link":"/iOS上架流程-踩坑集/"},{"title":"Swift通过桥接文件使用OC","text":"前言在Swift语言开发的过程中，难免会用到一些用OC写的代码，这时候要么耗费一番精力用Swift重写，要么就得使用桥接的办法直接在Swift中使用。 桥接，其实也很简单，就是新建一个头文件，在头文件中引用需要直接使用的类的头文件即可。接下来，进行一个配置，就可以直接在Swift中import，在使用过程中非常玄乎的自己就转成了Swift的形式。 进击吧，桥接~1.创建桥接文件 首先，我们导入了OC部分之后，需要新建一个头文件，且，这个头文件的命名为——*项目名-Bridging-Header.h *。 2.桥接文件配置 1) 在桥接文件中，import需要使用的oc代码对应的头文件。#import &quot;需要使用的头文件名.h&quot;2）在Build Settings中，搜索Objective-C Bridging Header，出来之后将桥接文件的路径填入即可。 3.去用就好啦 是的，现在就可以直接使用了。没啥好说的…… 番外引用篇——添加第三方库（SDK）关于如何制作Framework以及使用，其实航哥的三篇文章很是详尽，就不多说，可以点这里看看。 库，又分成了静态库和动态库两种，这篇文章讲得就不错。","link":"/Swift通过桥接文件使用OC/"},{"title":"对美好生活的憧憬","text":"北京时间：2017年11月25日，晚19点44分。 坐标：苏州——某星巴克。 前言：离汤姑娘考研不到一个月，一个月后的生活充满了极大的不确定因素，但我依然也必须——对未来的生活充满美好憧憬。 1.近来，脑子里依然是有点混乱，又开始想着不知道条条通罗马的路我该走哪一条。准确点说，多想有个人告诉我：李小子，做这些事就行了，然后你就可以得到你想得到的。 话说，我想得到些什么呢?不如，让我暂且列举下： 把家里的事平了 工作，能让自己充满兴趣与激情，待遇自然得好 想做一个自己的产品——即便不能改变世界，也能正向的影响到部分人 结婚这件事，终归是要尽可能在25~28这段时间做到 如果上面的事情都结束了，出一本自己的书…… 接下来的日子应该得为孩子打拼一段时间…… 牵挂不断增加：父母，妻子和重要的亲朋，很多相关的事可能接踵而来，不由人 自己总归会找到至少一两件兴趣所在的事，并有所投入 抛开身不由己…… 不如，做一个浑浑噩噩的人？ 不对，做一个睁眼看世界的人。 最终，步入人生的必经之站…… 如果，似上面这般想来，突然间觉得有点庆幸——并没有人告诉自己去罗马要走哪条路，路上又会遇到些怎样的人物，发生怎样的故事或者事故。 2.对未来的生活，终归是充满美好憧憬。在公司里，经过差不多半年的学习终于也已经上手项目并完成任务。与汤姑娘的生活状态，也基本呈现稳定的状态，最有可能的波折应该就是考研之后这一段时期。至于家里的事，也罢，目前还不需要自己出场。 在小专栏上，竟然真的有人订阅自己的“木头的iOS填坑之路”，到账27元有余，小小激动。简书虽然长久未更新，但之前关于考研英语语法的整理依然时不时有人点赞。以及，个人博客的搭建，这些都在激励着自己进行写作。（ps.当然是和作家的写作，不必相比） 工作虽然不是很忙碌，甚至闲暇的时间还是比较充裕。一开始，自己也是有点混乱：一方面，想着以写“木头的iOS填坑之路”为契机整理所学，然而发现枯燥繁琐而且对自己的提升貌似不大就有所松懈。另一方面，想着加深iOS技术的学习，打算从RxSwift，RN开发，机器学习在iOS中的应用还有ARKit。可是当小老大变相的打击了学RxSwift的积极性之后，就对这一条发展路径开始了犹豫不定。还有一方面是，想着以FlagsGo这个个人Project为契机，整合所学，并学习新的内容（比如：网络爬虫、UI设计、文档编写和产品经理相关内容等）。目前来说，主要就是以这条路线在进行自学，其他两条路线时不时进行。 当把上面这一段文字在闹钟整理并输出之后，突然间又好像有一阵豁然开朗，我所需要做的就是把事情做完一件再做完一件。在我的工作和生活中如果没有出现新的机遇，以上的学习是我现在正需要的，无论是从本职工作出发还是本职之上的扩展。如果说，另外还需要做点什么，那只有两件：读书和锻炼。 3.看来，我还是找到了病症所在——希望不经历点困难和过程就能得到最后的果实，以及惰性萌生。 与汤姑娘的路，携手向前，就一定能到期许的那一天——埋在一起长眠。 家里的事，早已论证多次，这就不是事。 至于自己，一定是一个很棒的人。 汤姑娘差不多画画结束，该走了。 曾几何时，看到星巴克是不敢进去的，还有必胜客也有类似的感觉，而K记和M记倒不至于。 有的话可以说的绝对些——人唯有自强方能自立。 希望自己，耐得住枯寂，未来的美好生活就在脚下不远处。 后记：真的，真的，真的需要减肥和锻炼身体。","link":"/对美好生活的憧憬/"},{"title":"深度学习之卷积神经网络（CNN）","text":"前言：DeepLearning的学习之旅已经从感知机到逻辑回归，再经过了神经网络和深度神经网络，终于来到了对卷积神经网络的学习。以下内容，是以人脸识别为例进行实现的记录。 认识卷积神经网络卷积神经网络，刚知道这六个字的时候，脑子里是一片空白——完全不知道它能做些什么。想要对其一窥究竟，我们得从以下几个名词开始了解它： 卷积（Convolutional） 填充 (padding) 步长 (stride) 池化 (pooling) 卷积（Convolutional） 卷积，是一种运算方式，这便是我目前对它最直观的感觉。以一张图像[A]——5×5的一个二维矩阵，0~255的数值取值为例，对它进行卷积运算。此时，以一个3×3的二维矩阵[B]，矩阵的值则需要根据希望通过运算之后得到什么特征而设置。 将[B]的左上角与[A]的左上角重合，重合区域的值对应相乘再相加会得到一个新的值a，a则是一个新矩阵左上角的值。紧接着，矩阵[B]平移一个单元，再次计算得到值b。再继续向右移动，此时[A]&amp;[B]最右边刚好重合，同样计算得到值c。此时，新的矩阵，就得到了第一行的所有值[a b c]。接下来计算的时候，便是要将矩阵[B]向下平移一行，并继续从最左边开始直到矩阵[A]&amp;[B]最下边和最右边同时重合，则结束了此次卷积运算并得到了一个新的3×3的矩阵[C]。用公式表示： [A] * [B] = [C] ps：偷懒没有把[C]所有值都计算…… 填充（padding） 通过上一段的卷积运算，可以发现最终能够把一个5×5的矩阵[A]通过一个3×3的矩阵[B]（过滤器）进行卷积运算之后得到新的3×3的矩阵[C]。会发现，经过这样的计算之后，矩阵[A]缩水了，而且这个过程中，有的数值参与的运算多，有的少，这必然也造成了一些边缘信息的丢失。所以，为了保留更多的信息，以及防止卷积不断进行矩阵不断缩小。可以对矩阵[A]进行填充，即在原有的基础上，给它的外围再裹上一层使之成为6×6的矩阵，最外围的一层都是0。这样再进行卷积运算之后，得到的新矩阵将依然是5×5。 至于填充的层数，根据自己的选择进行，可填n层，也可不填。 步长（stride） 在进行卷积运算时，矩阵[B]每次都是向右移动一个单位，这一个单位也就是指步长为一。可以清楚的认识到，步长的设置，将影响到矩阵移动的速度，以及对特征的提取。当步长为2时，每次向右移动都是两个单位，向下移动也是两个单位。 商不是一个整数怎么办?在这种情况下，我们向下 取整。⌊ ⌋ 这是向下取整的符号，这也叫做对 z 进行地板除(floor)，这意味着 z 向下取整到 最近的整数。这个原则实现的方式是，你只在蓝框完全包括在图像或填充完的图像内部时， 才对它进行运算。如果有任意一个蓝框移动到了外面，那你就不要进行相乘操作，这是一个 惯例。你的 3×3 的过滤器必须完全处于图像中或者填充之后的图像区域内才输出相应结果，这就是惯例。因此正确计算输出维度的方法是向下取整 池化（pooling） 池化，又是另外一种运算。一般分为两种，一是最大值池化，一是平均值池化。（仍然以上文提到的三个矩阵[A]、[B]、[C]为例） 最大值池化：当矩阵[B]重在矩阵[A]上面时，选取其中的最大值，将其提出作为新矩阵[C]的第一个值，依次进行。 平均值池化：计算过程类似，只是这次提取的是范围类矩阵[A]的数值相加后求出的平均值，以该值作为矩阵[C]的值。 池化层用来缩减模型的大小，提高计算速度，同时提高 所提取特征的鲁棒性。 卷积网络如何进行学习鉴于自己的数学水平有限，对其公式并不做具体展开阐述。详情推荐博文。 本质上依然是前向传播，然后反向传播，梯度递减，更新权重（理解为此处的过滤器，不知道是否有误）。 另外，在使用框架如：TensorFlow、Keras、Pytorch时，都是会有封装好的方法，传入相应的参数直接使用即可得到公式推导的结果，这样可以很好的帮助到理解了相关理论，但是数学推导能力薄弱的自己。 再次以图像举例，一张图像一般是RGB三通道，所以矩阵[A]，就会是一个三维度的5×5矩阵，这样过滤器也需要是三维度，不过，最后得到的值还是依然为一个维度。而这里，就得稍作提醒，不同的框架下，一般通道数这个参数位置或前或后，不一致。 关于上段的一些补充： 输入矩阵的通道数和过滤器的通道数一定相同，过滤器的长宽可以不同。 过滤器与输入矩阵重合后对应数值相乘再相加，所以最终的输出是一个一维的矩阵。 如果，过滤器的数目增加，有n个，则最终的输出是一个n维的矩阵。 为什么使用卷积网络卷积网络因其参数共享&amp;稀疏连接这两个特性，可以减少参数，以便我们用更小的训练集进行训练，防止过度拟合，并能够节省计算消耗，缩短计算时间。 参数共享：“特征检测如垂直边缘 检测如果适用于图片的某个区域，那么它也可能适用于图片的其他区域。” 稀疏连接：“输出值只与过滤器范围内的参数有关，与其他无关，不会受影响。” Parameter sharing: A feature detector(such as a vertical edge detector) that`s useful in one part of the image is probably useful in another part of the image. *Sparsity of connections: *In each layer, each output value depends only on a samll number of inputs. 稍稍想想，如果不用卷积，在真是情况下对一张图片进行全连接网络深度学习，那这个参数就是极大的，特别在深度不断加深且照片数目增加的情况下，将极大的占据计算资源。所以，卷积神经网络的使用有其必要性。 参考：1、零基础入门深度学习(4)-卷积神经网络2、网易云课堂,深度学习微专业, 吴恩达.3、Coursera深度学习课程笔记, 黄海广.","link":"/深度学习之卷积神经网络（CNN）/"},{"title":"深度学习之实现人脸识别","text":"根据网上的一些资料教程，自己动手实现了人脸识别的程序，GitHub地址。 前提概要在整个环境配置过程中，比较麻烦的就是安装openvc，以及安装dlib库。当这两个库安装成功，基本上就可以畅通的进行以抄代码为主的学习之旅了。此外，关于卷积网络的简单了解也是一件很有必要的事情，可以有助于抄代码时的理解。 人脸识别两部走人脸识别可以分为两大部分:人脸检测和人脸验证。前者，在图像或视频中检测出人脸部分；后者则是对人脸进行验证，查验是否为某某。另外，加上活体检测基本上就可以避免在业务环境中，人为的作假是可以极大的降低。 ps:在本例子中，并没有活体检测…… 人脸检测关于人脸检测，没有亲自从底层去实现或者优化如何检测人脸。而是采用了opencv和dlib进行人脸检测，在使用过程中发现dlib的识别精度更为高一些，而opencv的识别速度更为快，具体体现在：当Mac摄像头打开后，dlib非常卡顿，于是测试了一下，用dlib库的get_frontal_face_detector()检测器检测耗时需要1秒+。不过，当摄像头窗口只是显示一个低像素下的人脸时效果会好很多。 具体代码可以看GitHub，注释都还是抄的比较详尽的，切记先看readme。此处只说说几个需要注意的地方 获取Mac摄像头，capture = cv2.VideoCapture(0)参数是0，有的资料是1或其他，反正我测试之后都是不行。 opencv的预置模型是存成了xml文件在安装opencv中的一个文件夹下，我这里提取出了自己测试的几个模型放在了**face_opencv_model文件夹之中。而dlib库则是函数式的调用即可。另外，opencv和dlib都不仅仅可以识别人脸，还有一些人脸特征部分也是有预置模型，dlib更是有着人脸特征点的提取。 尽管没有从底层实现人脸检测，不过根据查阅的资料，隐约还记得一个向量相关的概念，暂做记录以备理解。不对之处，敬请指正。 用向量表示了整个图像，如此一来，通过向量的走向，是可以看出一个人脸的模子的。 在具体代码中，主要是做了通过Mac打开摄像头，截取了自己的人脸照片作为数据集。以及，在训练模型之后，打开摄像头，预测视频中的人脸是否为自己。 人脸验证人脸验证，主要是用到了深度学习中的卷积神经网络。简单的说下，直接用深度神经网络是不大适合的，会耗费过多的运算算力。关于卷积神经网络，具体的还是可以看看之前的博文。 在代码中，主要是用Keras来搭建模型，以及训练，保存，预测引用。Keras是在TensorFlow之上的又一个框架。非常棒的一点是，它有中文版的API文档，而且API设计的更为人性化易于理解。 根据网上教程示例，敲完之后总结如下： 模型不清楚是按照什么理论设计的……反正，这本身就是个玄学。虽然训练效果是精准度95%左右吧，可是在识别过程中还是会存在超过想象的误差。模型的设计，真的不知道该怎么有迹可循。反正，我是直接照搬的博主的模型。 其实在最开始，是通过吴恩达课程练习了人脸识别，不过课程练习没有加入视频和人脸检测，但是用了迁移学习。不过迁移学习相关的代码又都是已经给好了…… 整体上来说，本例中的人脸识别，除了网络用成了卷积神经网络，模型用了某位博主的。依然是深度学习中——对标签数据，通过前向传播再反向传播，梯度递减权重更新，设置学习率迭代数，获得一个模型参数然后加以应用，如是这般的一个套路。 具体的代码，依然是看GitHub，毕竟我抄的注释和自己理解的注释还是比较详尽的。 后记： 我知道自己抄的代码也好，还是理解的一些理论肯定有不少不足的地方。希望有朋友如果看了之后，可以指点一番，也欢迎一起交流。可以在博客上通过邮件联系我，谢谢！","link":"/深度学习之实现人脸识别/"},{"title":"逝去的2017，现在的2018","text":"前言： 今天都已经是公历2018的第三天，险些又往后顺延码字。这便是一个最真实的写照——一面不甘，一面堕落。 跨年还是很开心的原计划的跨年是和汤姑娘一起去绍兴，住宿都已经一早预定。然而，当知道小景子在31号晚上生日，便决定组织大家聚一波。起先，地点选在了上海，可当陪汤姑娘经历了上海考研的几天，再加上与小飞吃了顿饭之后，深感6个人若是在上海跨年之后恐怕新的一年就得开始吃土。 说来也巧，都已经过了检票的时间，幸亏安检员放行，和汤姑娘冲上高铁之后不到1分钟便关了门。当女朋友缓过气走向车厢时就听到她“咦”地一声，原来是看到了约好同班车的小飞。 回到苏州的家，先拉着小飞去了超市买上晚上聚餐的一些准备物品。再回到家没一会，紧接着便是小景子和他女票也下了公车。当带着小飞和小景子二人在市场逛荡着买火锅的原料时，最后一位到的鑫宇也下了公车。 一晚上，说不热闹吧，大家也是都吃的肚满肠肥，围着个锅不停地叽叽喳喳。说热闹吧，鑫宇女朋友没有来，多说有点心不在焉，话不多；科科没到不知道做着什么（后来视频，知道在外面也聚着）；汤姑娘虽然不认生，却也不熟只得自顾自的吃；剩下的三人多以聊着老板如何、论文如何、同门如何。 得知大家都是次日上午便要匆匆回到南京、上海、杭州，便匆匆拉着众人打车去了星巴克想着赶在打烊前庆生。结果，也只是喝了一杯，打了几局牌，在这人造的老街走了一圈又到景住的宾馆才赶在2018前5分钟点了蜡烛，又吹灭了蜡烛，分了蛋糕。是了，还有在我们的406大家庭打开了群视频，没来的二人也是都赶在了一起，庆了生&amp;跨了年。 一个人的生日，能够得到朋友真挚的祝福是很幸福的事，能赶在跨年这样的日子更是很幸运的事，希望小景子新的一年一切顺利，希望当晚的友人们及我一切顺利。 小飞和鑫宇最终还是没有找到住宿，在我家过了夜，和小景子分别时拥抱了一下。次日一早，7点多就被鑫宇的敲门声叫醒，赶紧着穿了衣服，一番洗漱，就骑车带着鑫宇到了公车站。和他拥抱，看着他上车，挥手，看着他坐下来，看着公车驶向前方，我便骑车回了家，上了床。 没有一会，小飞也起了床，说好给他下一晚热腾腾的面，待他吃完，便和他步行到车站，一路说了很多。车很快就来了，和他拥抱，看着他上车，挥手，看着他坐下来，看着公车驶向前方，我便走回了家…… 这一天，是我的2018年的开始，从送别开始。 演唱会原来有这么多人会哭汤姑娘喜欢张惠妹，某日，狠下决心买了2017.12.30晚，张惠妹上海演唱会的票。票是二层看台，差不多算是中央位置，一晚上下来感觉这个位置蛮好。刚到场时，感觉人貌似不多，周围也都是稀稀疏疏的几人。可是，当到了晚上7.30演唱会即将开始的时间时，整个梅赛德斯场馆里感觉满满的都是人，燥热。 汤姑娘坐在我左边，她的左边，是一对中年夫妻，男的比较沉稳，女的脸上还是透着点激动。再往左，有一个胖子兄，这位胖子兄可激动了，当一些快歌的时候，我这个位置是可以感受到他站起来蹦跳的震动。我的右边是自己一个人来的30岁上下的一个女人，刚来的时候有点手忙脚乱的，演唱会开始后便比较安静的看着听着，有时候又会出现点激动可是又有所克制，当周围都站起来一起跟着节奏蹦跳，她才释放的站了起来，可是很快又坐了下去。 有人追这场演唱会追了十几场，还打印了横幅。有人从台北一直追到这，张惠妹都知道他是双口吕的吕先生。 张惠妹一晚上哭了好几次，唱着哭着，哭着唱着，虽然我听不太出来哭腔。一些二十多岁的男男女女在哭，一些三四十的男人和女人在哭，汤姑娘也在我肩头哭了一两次（也有过一两次亲了我，牵我的手）。我不是很能理解，为什么这些人会哭，汤姑娘是个小孩，我还能理解，可是他们中更多的人是大人，是在外面承受再多委屈也不苦的那些人，为什么就一两首歌就哭了呢。不懂，不解。出了这个馆，外面还是很冷的，而且还下着小雨。出租车都把路口堵住了，后面的出租按喇叭，前面的冲着后面的嚷嚷。 地铁口，挤满了人，当我和汤姑娘被后面的人挤进了口子，今晚的演唱会也算是结束了。 关于工作的总结记录展望啥的，等到真正的年来临之际再写出来。","link":"/逝去的2017，现在的2018/"},{"title":"Flagsgo之Demo(夭折)版","text":"前言：终于，完成了Flagsgo的Demo版本。从诞生想法至今日，将近两个月有余，从而得出结论——自己的能力有太大的提升空间。 这段日子，做了个Demo——Flagsgo 想法之初大致三个月前建了个微信群，拉着小景子与大飞侠每天打卡背单词，特地在公平自愿的原则下立了规矩——无论何种理由，只要有一天没有打卡便要认罚（红包&amp;罚抄）。目前，自己已经发出三次共计70元的红包，罚抄1500+的words。随之而来的是，每天与这两位仁兄在毕业后也多了一份羁绊，另外便是词汇量多少还是有所增加。 与此同时，一种想要做个东西的想法又按不住的冒了头。其实，以前在学校做Android的时候也有过一些idea，出现过和图书相关的一个idea，还出现过和宠物社交相关的idea，貌似还有过一个记不清的idea。显而易见的是，以往的想法并没有付诸于coding。 当某个周末的洗澡过程中，脑海中一系列的化学反应之下，关于Flagsgo的idea就自己跑了出来。穿好衣服从卫生间跑出来，便赶紧跟汤姑娘阐述自己的所想，好似面对着自己的投资人一般…… 畅想版本: Flagsgo，未来的它一定是能对用户做出正向的影响，而且本身具有一定的商业价值。Flagsgo通过备忘提醒这个核心嵌入点，加入好友互助提醒分赏金的游戏方式，可以同时兼有【工具】、【社交】和【金融】的因子。 行动之初UI在一张大纸上思维导图式的整理了下最初的想法，紧接着便计划把整个UI的草稿涂涂画画，在画初稿的过程中想到可以用Sketch做icon和logo等。但是，当自己上手的时候发现脑海的想法并不方便实现，而且我并不会制作icon和logo。 在网上找了几篇Sketch的教程，对软件本身的简单使用的确不成问题。然而，就像会用笔不代表写得了书法一般，没有设计的基础和积累，我的脑海是一片空白。直到最后转到使用墨刀，做了一两个界面之后又开始了边开发边考虑布局等等。 iOS实现核心功能的精简一开始想着要有社交，要有类似红包这样的游戏功能，另外便是最基本的提醒功能。尽管在做了一定了解之后发现做即时通信有现成的SDK可以使用，红包功能也可以想着用微信或者支付宝来曲线救国。实际开发时，却发现要在最初版本做到这些对于自己实在是太大的工作量，而且由于目前没有架构的能力，可以预见之后的版本一定是推倒前面重写…… 最终，各种功能是砍了又砍（ps.最开始想着直接把金融这块功能做了，绝对是年少轻狂不懂事），最终便只剩下了如下的主要功能： 实际版本: 实际的开发中，发现自己一个人能力有限，而且有些事情现在没有办法实施。而且，当发现市场上竟然有类似自己畅想版本的App存在，在开发的原动力上多少有点打击。如此一来，便真的只是纯纯的锻炼自己。保留最最基本的工具功能，备忘提醒。加上诗词欣赏以及查看当地天气这两项功能。 最烦的是逻辑Coding的过程是很难受的，因为不断发现想法很好实现很难，干脆不会。虽然，到最后这个Demo版本，基本没有任何有难度的功能，至少看起来单一的功能都的确是简单。可是，这里面也有不少知识点，特别是和业务逻辑结合在一起就更是如此。 iOS不知道怎么实现闹钟功能，反正找不到直接调用系统闹钟的方法。最后就取巧，通过本地通知的形式做提醒。知识点1：多个通知的唯一标识不能相同，否则无法响应通知。 获取经纬度，地理编码转码。 【收藏】功能多处的联动。 数据本地存储，以及根据业务逻辑的增删。 TextView自适应高度。 TableView的类型选择，以及使用。 …… Python之数据&amp;服务很久以前想过做爬虫，认为会写爬虫的程序猿比较cool，也比较极客风。能这么说，肯定是以前被爬虫给唬住了，止步了。事实证明，毛爷爷说的太对了——XXX都是纸老虎。 Python学习在同事那里借了一本Python的书，便开始了差不多一个多星期的Python之旅。过语法用了差不多两天的样子，两年前边看边敲了一遍《Learn Python the hard way》，可是再回顾语法的时候真的是没太多印象。这又证明了——如果一门技能或知识学了不用，时间久了，生疏可能是最好的结果。 过完语法之后的自己，又开始拿着书敲一个游戏的例子。刚开始还好，有股子冲劲，可人真的是有惰性的。而我更是好吃懒做，巴不得这本书我只看一眼就能很熟练的掌握，以致于在这个学习的过程中越敲代码越抗拒越吃力。 好在，最终拖拖拉拉的一个星期总算把游戏的例子敲完，剩下关于数据分析和web应用程序开发的能容则是看了好几遍。在这里，真的是庆幸自己毕业后来到的单位不是血汗工厂，而且所在的部门氛围特别舒服，自己得以在工作中还能继续学习。（可惜我这马屁了，老大看不到） 爬虫获取数据回到正题，Python爬虫，网上有好多例子，可是不知道为啥子就是不想跟着敲那种爬百度百科的，爬淘宝MM的（不爬MM图片，这不应该呀……）。自己直接根据一个爬二手车信息的例子，写起了爬某个诗词网站的爬虫程序。爬二手车信息的例子唯一能给自己的帮助就是，原来要用这几个库，以及了解到简单的爬虫就是：访问网页-&gt;解析HTML-&gt;抓取数据-&gt;存储数据。 在经过解析诗词网站的HTML，和解决解析数据与存取数据出先的BUG之后，终于完成了自己的第一版Python爬虫。 MongoDB存取数据数据存储一开始，自己是直接写在了文件之中。可是当试图开始要去发布服务，为iOS展示诗词提供数据时，发现服务返回的应该是JSON，文件处理起来就感觉比较麻烦。便进了MongoDB这个坑，当然，以我爬到的几千首诗词用其他的数据库也无不妥。 遇到新的知识，只好又是看博客，反正数据库以前也是用过的，而且那时候在班里也是能66的教其他同学。果不其然，简单的数据增删改查很简单，而且数据可以直接导出成json格式，这简直太棒了。 ps.值得一提的是，MongoDB原来是看不到的呀。 Flask发布服务之前复刻项目和做项目时，网络请求数据或上传数据就总用到服务，感觉这是个很厉害的东西，别人只是给了自己一个接口，但是却处理了很多事。 3年前其实就接触过服务端，那时候是为了给第一个Android项目写数据的上传下载，可是实验室没人写后端服务，自己也没有后端的概念。刚开始，看到一些博客的例子，很是不理解为什么自己照着写，可是每次进行上传或者下载的时候就报错。在这，纠结了一周左右用PHP写了个小服务，才自己摸索到了后端相关的一些概念，那时候的自己真是不开窍。 又说多了。因为多少有点相关概念在脑子，而且知道Python可以写服务，正好组里有高手。通过高人指点，直接看Flask的一个教程，跟着敲了几行代码，渐渐有了头绪。刚开始只能本机访问，后来能够做到局域网内访问，最后不仅可以服务发数据（例如，服务发布诗词数据），还能接受数据（例如，收到用户反馈的信息并写入文件）。 经验总结虽然Flagsgo的Demo版本没有进行上架（哪里有脸上架），而且服务也没有弄在公网上，但是基本对一个App想法-&gt;实现走了一遍流程。 简单的总结如下： 坚持，真的是会有收获。 一个人的能力实在有限，难以面面俱到。但这不妨碍我们朝着全栈发展，只是个人感觉，还是要有所突出。 宏观上的产品架构薄弱，App整体设计与开发的架构能力都等于无能力。 目前开发效率低下，状态基本是边开发，边想，边调整，边学习这般循环。如果自己一个人做个产品，迭代速度会跟不上。","link":"/Flagsgo之Demo-夭折-版/"},{"title":"Moya初体验","text":"前言以往在需要进行网络请求时，都是直接使用Alamofire，尽管知道有Moya的存在。但是，出于对未知事物的畏惧心理，并没有尝试去了解并实现一个例子。终于，由于戴老师整理核心库的代码使用了Moya，并且建议自己在下一个项目中也用上，于是才发现——Moya，并没有想想那么恐怖。 Moya，是一个基于Alamofire更高层网络请求封装抽象层。它定义了一个清晰的网络结构，通过枚举定义不同的请求；可以简单的进行网络单元测试（还未尝试过单元测试）。Moya主页给出了一幅图说明使用了它之后，整个网络请求可以更干净整洁。 ps.做个说明，所实现的例子是对航哥提供的教程系列不完全实现。 Moya,来吧！简要的说明，Moya会提供一个Provider，我们要做的就是定义我们的Target以初始化自己的Provider，然后在需要进行网络请求的地方直接用即可。是的，就这么简单，没了。 提供自己学习航哥的GitHub代码以供参考。 实现Moya首先，需要新建一个Swift文件，比如DouBanAPI.swift。现在开始写代码，配以注释讲解，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import Foundationimport Moya // 肯定是需要导入Moya的库// 通过枚举的方式，定义请求分类public enum DouBan { case channels //获取频道 case playlist(String) // 获取歌曲}/***************************************************************/// 通过扩展的方式，给枚举DouBan，实现TargetType 协议。// 请求配置，以下的几个方法都是必须实现的。extension DouBan: TargetType { // 服务器地址 public var baseURL: URL { switch self { case .channels: return URL(string: \"https://www.douban.com\")! case .playlist(_): return URL(string: \"https://douban.fm\")! } } // 各个请求的具体路径 public var path: String { switch self { case .channels: return \"/j/app/radio/channels\" case .playlist(_): return \"/j/mine/playlist\" } } // 请求类型 // Post 和 Get 方法的不同，参数传递的方式也不同。 // Get: 参数直接拼接在 url 上，可见。 // Post: 参数是放在 Http body 中传递，url 不可见。 public var method: Moya.Method { return .get } // 请求任务事件 // 如果将参数中一个值设置为 nil，那么不管是在 Get 还是 Post // 这个参数是不会传递的 public var task: Task { switch self { case .playlist(let channel): var params: [String: Any] = [:] params[\"channel\"] = channel params[\"type\"] = \"n\" params[\"from\"] = \"mainsite\" return .requestParameters(parameters: params, encoding: URLEncoding.default) default: return .requestPlain } } // 是否执行Alamofire验证 public var validate: Bool { return false } // 这个是做单元测试模拟的数据，只会在单元测试文件中有作用 public var sampleData: Data { return \"{}\".data(using: .utf8)! } // 请求头 public var headers: [String: String]? { return nil }} 至此，关于本例要用的Moya便算是完成了，就是这么一个简单的类，接下来在网络请求中去用就行啦。在我们具体的项目中，主要做以下两个方面的更新： 根据请求的数目（内容），定义自己的枚举。 更改自己在扩展Target协议中对应的方法，比如：某个请求是post,某个是get,需要switch即可;某个请求传参是A、B，某个是E、A、F，也是根据自己的项目而改变即可。 Moya，用起来！此时，已经可以开始在需要进行网络请求的地方去使用。使用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// 在需要使用的地方初始化Providerlet DouBanProvider = MoyaProvider&lt;DouBan&gt;()// 简单的用法DouBanProvider.request(.playlist(channelId)) { result in // 网络请求返回成功 则进行相关处理 if case let .success(response) = result { // 解析数据，获取歌曲信息 let data = try? response.mapJSON() let json = JSON(data!) let music = json[\"song\"].arrayValue[0] let artist = music[\"artist\"].stringValue let title = music[\"title\"].stringValue let message = \"歌手：\\(artist)\\n歌曲：\\(title)\" //将歌曲信息弹出显示 self.showAlert(title: channelName, message: message) }}/***************************************************************/// 考虑到多种情况：成功，失败，错误状态码处理// 使用我们的Provider进行网络请求（获取频道列表数据） DouBanProvider.request(.channels) { result in switch result { case let .success(response): do { // 过滤成功的状态码响应 try response.filterSuccessfulStatusCodes() // 解析数据 let data = try? response.mapJSON() let json = JSON(data!) self.channels = json[\"channels\"].arrayValue // 刷新表格数据 // 异步进行 DispatchQueue.main.async { self.tableView.reloadData() } } catch { // 处理错误状态码的响应 } // switch里面可以继续 switch case let .failure(error): switch error { case .imageMapping(let response): print(\"错误原因：\\(error.errorDescription ?? \"\")\") print(response) case .jsonMapping(let response): print(\"错误原因：\\(error.errorDescription ?? \"\")\") print(response) case .statusCode(let response): print(\"错误原因：\\(error.errorDescription ?? \"\")\") print(response) case .stringMapping(let response): print(\"错误原因：\\(error.errorDescription ?? \"\")\") print(response) case .requestMapping: print(\"错误原因：\\(error.errorDescription ?? \"\")\") print(\"nil\") case .objectMapping(_, _): break case .encodableMapping(_): break case .parameterEncoding(_): break case .underlying(_, _): break } } }/***************************************************************/// 为了代码的干净简洁，我们可以选择封装一下返回状态的处理struct Network { static let provider = MoyaProvider&lt;DouBan&gt;() static func request( _ target: DouBan, success successCallback: @escaping (JSON) -&gt; Void, error errorCallback: @escaping (Int) -&gt; Void, failure failureCallback: @escaping (MoyaError) -&gt; Void ){ provider.request(target) {result in switch result { case let .success(response): do { //如果数据返回成功则直接将结果转为JSON try response.filterSuccessfulStatusCodes() let json = try JSON(response.mapJSON()) successCallback(json) } catch let error { //如果数据获取失败，则返回错误状态码 errorCallback((error as! MoyaError).response!.statusCode) } case let .failure(error): //如果连接异常，则返沪错误信息（必要时还可以将尝试重新发起请求） //if target.shouldRetry { // retryWhenReachable(target, successCallback, errorCallback, // failureCallback) //} //else { failureCallback(error) //} } } }}// 基于封装后的NetWork，进行网络请求Network.request(.playlist(channelId), success: { json in // 获取歌曲信息 guard json[\"song\"].arrayValue.count &gt;= 1 else { return } let music = json[\"song\"].arrayValue[0] let artist = music[\"artist\"].stringValue let title = music[\"title\"].stringValue let message = \"歌手：\\(artist)\\n歌曲：\\(title)\" // 将歌曲信息弹出显示 self.showAlert(title: channelName, message: message) }, error: { statusCode in // 服务器报错等问题 print(\"请求错误！错误码：\\(statusCode)\") }, failure: { error in //没有网络等问题 print(\"请求失败！错误信息：\\(error.errorDescription ?? \"\")\") }) 关于Moya的常规使用，以上的方法足矣。 Moya，可以加插件在网络请求时，都是得耗费一定的时间，这个时候一般会转动一个小菊花。通过Moya，可以在网络请求过程中添加一个菊花插件，使其在请求时出现，请求结束后消失。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import UIKitimport Moyaimport Resultfinal class RequestAlertPlugin: PluginType { // 当前的视图控制器 private let viewController: UIViewController // 活动状态指示器 （菊花） private var spinner: UIActivityIndicatorView! // 插件初始化的时候传入当前的视图控制器 init(viewController: UIViewController) { self.viewController = viewController // 初始化活动状态指示器 self.spinner = UIActivityIndicatorView(activityIndicatorStyle: .gray) self.spinner.center = self.viewController.view.center } // 开始发起请求 func willSend(_ request: RequestType, target: TargetType) { // 请求时在界面中央显示一个活动状态指示器 viewController.view.addSubview(spinner) spinner.startAnimating() } // 收到请求 func didReceive(_ result: Result&lt;Response, MoyaError&gt;, target: TargetType) { // 移除界面中央的活动状态指示器 spinner.removeFromSuperview() spinner.stopAnimating() // 只有请求错误时会继续往下执行 guard case let Result.failure(error) = result else {return} // 弹出并显示错误信息 let message = error.errorDescription ?? \"未知错误\" let alertViewController = UIAlertController(title: \"请求失败\", message: \"\\(message)\", preferredStyle: .alert) alertViewController.addAction(UIAlertAction(title: \"确定\", style: .default, handler: nil)) viewController.present(alertViewController, animated: true) }} 上面的代码，便实现了插件小菊花。在使用的时候，定义Provider有所区别，需要添上插件。 let DouBanProvider = MoyaProvider(plugins: [ RequestAlertPlugin(viewController: self) ]) 小贴士当有多个Target时，即可以分别写个Provider，也可以用一个Provider。分别写没啥好说的，多个对一个的写法如下： 12345let provider = MoyaProvider&lt;MultiTarget&gt;()provider.request(MultiTarget(DouBan.channels)) { result in}","link":"/Moya初体验/"}],"tags":[{"name":"深度学习","slug":"深度学习","link":"/tags/深度学习/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"人脸识别","slug":"人脸识别","link":"/tags/人脸识别/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Pygame","slug":"Pygame","link":"/tags/Pygame/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"Pygal","slug":"Pygal","link":"/tags/Pygal/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"经验整理","slug":"经验整理","link":"/tags/经验整理/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"SideProject","slug":"SideProject","link":"/tags/SideProject/"},{"name":"学习轮子","slug":"学习轮子","link":"/tags/学习轮子/"}],"categories":[{"name":"深度学习","slug":"深度学习","link":"/categories/深度学习/"},{"name":"Python系列","slug":"Python系列","link":"/categories/Python系列/"},{"name":"iOS系列","slug":"iOS系列","link":"/categories/iOS系列/"},{"name":"记录","slug":"记录","link":"/categories/记录/"},{"name":"Works系列","slug":"Works系列","link":"/categories/Works系列/"}]}